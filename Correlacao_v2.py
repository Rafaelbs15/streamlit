# -*- coding: utf-8 -*-
"""Correlacao_v2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14VJtfvbN_2TUJS9SXmbKBxc_ikqECs04
"""

#!pip install pandas
#!pip install altair
#!pip install requests
#!pip install urllib

import pandas as pd
import altair as alt
import requests
from urllib.parse import urlparse
import matplotlib.pyplot as plt
import seaborn as sns
import streamlit as st

st.set_page_config(page_title="An√°lise SARESP", layout="wide")
st.title("üìä An√°lise de Correla√ß√£o - SARESP, Simulado e Ra√ßa")

SHEET_URLS = {
    "simulado_id_9anoJundiai_e_Sul1": "https://docs.google.com/spreadsheets/d/1WdYDSdSnoZYGrqOZQ6et0ATZ6I_cn68sy40TDvU-7us/edit",
    "saresp_jundiai": "https://docs.google.com/spreadsheets/d/1rVWqlFSdWczK0SYZ4ecSdloJJ4BNllgy7m0K5q9G31Q/edit",
    "saresp_sul1_5_e_9ano": "https://docs.google.com/spreadsheets/d/1mMU5WVwGLQhSf_AwKBXJVaSyMOsqplZqaUeBLAQf-iM/edit",
    "simulado_sul1": "https://docs.google.com/spreadsheets/d/1iuHE5IHQUVaIuo2Z5x5wqJGT2VRJostnVrH40mvHfL4/edit?usp=drive_link",
    "simulado_sul2": "https://docs.google.com/spreadsheets/d/1A0L4YwrVFt77Up049RSdZ9Toe9FD-oXkjERkdppFy0g/edit?usp=drive_link",
    "raca_DEParceiras": "https://docs.google.com/spreadsheets/d/1tyeyM4xhf0KVXthCsSUGF3Wlc9cv4B1EBq7hHUJYV10/edit?usp=drive_link"
}

def carregar_sheet(id_planilha):
    url_csv = f"https://docs.google.com/spreadsheets/d/{id_planilha}/export?format=csv"
    return pd.read_csv(url_csv)

# ID da planilha do simulado (sem /edit no final!)
simulado_id_9anoJundiai_e_Sul1 = "1WdYDSdSnoZYGrqOZQ6et0ATZ6I_cn68sy40TDvU-7us"
saresp_jundiai = "1rVWqlFSdWczK0SYZ4ecSdloJJ4BNllgy7m0K5q9G31Q"
saresp_sul1_5_e_9ano = "1mMU5WVwGLQhSf_AwKBXJVaSyMOsqplZqaUeBLAQf-iM"
simulado_id_5anoSul1 ="1iuHE5IHQUVaIuo2Z5x5wqJGT2VRJostnVrH40mvHfL4"
simulado_id_5anoSul2 = "1A0L4YwrVFt77Up049RSdZ9Toe9FD-oXkjERkdppFy0g"
raca_DEParceiras = "1tyeyM4xhf0KVXthCsSUGF3Wlc9cv4B1EBq7hHUJYV10"

# Carregar
df_simulado_id_9anoJundiai_e_Sul1 = carregar_sheet(simulado_id_9anoJundiai_e_Sul1)
df_saresp_jundiai = carregar_sheet(saresp_jundiai)
df_saresp_sul1_5_e_9ano = carregar_sheet(saresp_sul1_5_e_9ano)
df_simulado_5anoSul1 = carregar_sheet(simulado_id_5anoSul1)
df_simulado_5anoSul2 = carregar_sheet(simulado_id_5anoSul2)
df_raca_DEParceiras = carregar_sheet(raca_DEParceiras)

# Limpeza e filtro SIMULADO

# Filtrar Sul 1
df_sul1 = df_simulado_id_9anoJundiai_e_Sul1[df_simulado_id_9anoJundiai_e_Sul1['DE'].str.contains("SUL 1", case=False)]
df_jundiai = df_simulado_id_9anoJundiai_e_Sul1[df_simulado_id_9anoJundiai_e_Sul1['DE'].str.contains("JUNDIA√ç", case=False)]

# Calcular acertos
df_sul1['Acerto'] = df_sul1['Resposta'].apply(lambda x: 1 if x == 'Correto' else 0)
total_acertos_sul1 = df_sul1.groupby(['DE', 'SERIE_ANO', 'ESCOLA', 'Disciplina'])['Acerto'].sum().reset_index(name='Total_Acertos')
total_questoes_sul1 = df_sul1.groupby(['DE', 'SERIE_ANO', 'ESCOLA', 'Disciplina'])['Resposta'].count().reset_index(name='Total_Respostas')

df_jundiai['Acerto'] = df_jundiai['Resposta'].apply(lambda x: 1 if x == 'Correto' else 0)
total_acertos_jundiai = df_jundiai.groupby(['DE', 'SERIE_ANO', 'ESCOLA', 'Disciplina'])['Acerto'].sum().reset_index(name='Total_Acertos')
total_questoes_jundiai = df_jundiai.groupby(['DE', 'SERIE_ANO', 'ESCOLA', 'Disciplina'])['Resposta'].count().reset_index(name='Total_Respostas')

# Juntar para SUL 1
df_sul1_completo = pd.merge(
    total_questoes_sul1,
    total_acertos_sul1,
    on=['DE', 'SERIE_ANO', 'ESCOLA', 'Disciplina']
)

# Juntar para JUNDIAI
df_jundiai_completo = pd.merge(
    total_questoes_jundiai,
    total_acertos_jundiai,
    on=['DE', 'SERIE_ANO', 'ESCOLA', 'Disciplina']
)

# Combinar tudo em um √∫nico DataFrame
df_final_simulado = pd.concat([df_sul1_completo, df_jundiai_completo], ignore_index=True)

df_final_simulado['Taxa_Acerto'] = (df_final_simulado['Total_Acertos'] / df_final_simulado['Total_Respostas']) * 100


# Limpeza e filtro SARESP

df_combined = pd.concat([df_saresp_sul1_5_e_9ano, df_saresp_jundiai], ignore_index=True)

df_final_saresp = df_combined[['DE', 'SERIE_ANO', 'ESCOLA', 'LP', 'MAT', 'MODALIDADE']]

# 4. Aplicar os mesmos passos de filtro e organiza√ß√£o do c√≥digo anterior

#Limpeza base de Raca

df_raca_DEParceiras = df.copy()
colunas_raca = ['Branca', 'Preta', 'Parda', 'Ind√≠gena', 'Amarela', 'N√£o declarada']

df_raca_DEParceiras[colunas_raca] = df_raca_DEParceiras[colunas_raca].fillna(0).astype(int)

# Somar diretamente as colunas 'Preta' e 'Parda' para obter o total de pessoas negras
df_raca_DEParceiras['Pretos_e_Pardos'] = df_raca_DEParceiras['Preta'] + df_raca_DEParceiras['Parda']

df_raca_DEParceiras['M√©dia_Branca'] = (df_raca_DEParceiras['Branca'] / df_raca_DEParceiras['Total']) * 100
df_raca_DEParceiras['M√©dia_Pretos_e_Pardos'] = (df_raca_DEParceiras['Pretos_e_Pardos'] / df_raca_DEParceiras['Total']) * 100

df_raca_Sul1eJundiai = df_raca_DEParceiras[df_raca_DEParceiras['DE'].isin(['SUL 1', 'JUNDIAI'])]

# Configura√ß√µes para evitar quebra de linha e truncamento
pd.set_option('display.max_columns', None)      # Mostrar todas as colunas
pd.set_option('display.width', None)            # Ajustar largura autom√°tica
pd.set_option('display.max_colwidth', None)     # Mostrar todo o conte√∫do das c√©lulas
pd.set_option('display.expand_frame_repr', False)  # Evitar quebra de linha no DataFrame

# Lista de tabelas e seus nomes (em ordem correspondente)
nomes_tabelas = [
    "Saresp",

]

tabelas = [
    df_raca_Sul1eJundiai


]

# Exibe cada tabela com seu nome, sem √≠ndice e sem quebras
for nome, df in zip(nomes_tabelas, tabelas):
    print(f"\n=== {nome} ===")
    print(df.to_string(index=False))

print("Colunas em df_final_simulado:", df_final_simulado.columns.tolist())
print("\nColunas em df_final_saresp:", df_final_saresp.columns.tolist())
print("\nColunas em df_raca_Sul1eJundiai:", df_raca_Sul1eJundiai.columns.tolist())

# Configura√ß√µes para evitar quebra de linha e truncamento
pd.set_option('display.max_columns', None)      # Mostrar todas as colunas
pd.set_option('display.width', None)            # Ajustar largura autom√°tica
pd.set_option('display.max_colwidth', None)     # Mostrar todo o conte√∫do das c√©lulas
pd.set_option('display.expand_frame_repr', False)  # Evitar quebra de linha no DataFrame

# Lista de tabelas e seus nomes (em ordem correspondente)
nomes_tabelas = [
    "Agregado",

]

tabelas = [
    df_combined


]

# Exibe cada tabela com seu nome, sem √≠ndice e sem quebras
for nome, df in zip(nomes_tabelas, tabelas):
    print(f"\n=== {nome} ===")
    print(df.to_string(index=False))

## FUN√á√ïES DE VISUALIZA√á√ÉO DE DADOS

# Adi√ß√£o de valores nas barras e colunas dos gr√°ficos
def valor_barras(plot, casas_decimais):
    """Adiciona valores nas barras/colunas de um gr√°fico"""
    for valor in plot.containers:
        plot.bar_label(valor, fmt=f'%.{casas_decimais}f', label_type='edge')


# Gr√°ficos b√°sicos com uma vari√°vel
def grafico_colunas_1(relacao, paleta):
    """Gera gr√°fico de colunas para uma vari√°vel"""
    grafico = sns.barplot(x=relacao.index, y=relacao.values,
                         hue=relacao.index, palette=paleta)
    return grafico

def grafico_barras_1(relacao, paleta):
    """Gera gr√°fico de barras horizontais para uma vari√°vel"""
    grafico = sns.barplot(y=relacao.index, x=relacao.values,
                         hue=relacao.index, palette=paleta)
    return grafico


# Gr√°ficos com duas vari√°veis
def grafico_colunas(relacao, coluna_x, tipo_relacao, paleta):
    """Gera gr√°fico de colunas para duas vari√°veis"""
    grafico = sns.barplot(data=relacao, x=coluna_x, y=tipo_relacao,
                         hue=coluna_x, palette=paleta)
    return grafico

def grafico_barras(relacao, coluna_x, tipo_relacao, paleta):
    """Gera gr√°fico de barras horizontais para duas vari√°veis"""
    grafico = sns.barplot(data=relacao, y=coluna_x, x=tipo_relacao,
                         hue=coluna_x, palette=paleta)
    return grafico


# Gr√°ficos agrupados
def grafico_barras_agrupadas(relacao, coluna_x, coluna_y, tipo_relacao, paleta):
    """Gera gr√°fico de barras agrupadas"""
    grafico = sns.barplot(data=relacao, y=coluna_x, x=tipo_relacao,
                         hue=coluna_y, palette=paleta)
    return grafico


# Gr√°ficos de setores (pizza)
def grafico_setores_1(relacao, paleta):
    """Gera gr√°fico de setores para uma vari√°vel"""
    plt.pie(relacao, labels=relacao.index,
           autopct="%1.1f%%",
           colors=sns.color_palette(paleta))

def grafico_setores(coluna1_dt, coluna2_dt, valor_dt, paleta):
    """Gera gr√°fico de setores filtrado por um valor espec√≠fico"""
    dados = dt[dt[coluna1_dt] == valor_dt]
    relacao = dados[coluna2_dt].value_counts()
    grafico_setores_1(relacao, paleta)


# Gr√°fico de dispers√£o
def grafico_dispersao(dataframe, coluna_x, coluna_y, paleta, cor_linha_tendencia):
    """Gera gr√°fico de dispers√£o com linha de tend√™ncia"""
    sns.scatterplot(data=dataframe, x=coluna_x, y=coluna_y,
                   color=paleta, marker='o')
    sns.regplot(data=dataframe, x=coluna_x, y=coluna_y,
               scatter=False, color=cor_linha_tendencia)

## AN√ÅLISE INTEGRADA USANDO DF_FINAL - SUL 1

# 1. CONFIGURA√á√ÉO INICIAL
plt.figure(figsize=(22, 7))
paleta_cores = {'SIMULADO': 'flare_r', 'SARESP': 'viridis_r', 'RA√áA': 'magma_r'}

# 2. GR√ÅFICO 1: DESEMPENHO NO SIMULADO (df_final_simulado)
plt.subplot(1, 3, 1)
df_simulado_sul1 = df_final_simulado[df_final_simulado['DE'].str.contains("SUL 1", case=False, na=False)]
media_simulado = df_simulado_sul1.groupby('Disciplina')['Taxa_Acerto'].mean().sort_values(ascending=False)

plt.title("Desempenho M√©dio no SIMULADO - Sul 1\n(por disciplina)")
grafico = grafico_barras_1(media_simulado, paleta_cores['SIMULADO'])
valor_barras(grafico, 1)
plt.xlabel('Taxa de Acerto (%)')
plt.ylabel('Disciplina')

# 3. GR√ÅFICO 2: DESEMPENHO NO SARESP (df_final_saresp)
plt.subplot(1, 3, 2)
df_saresp_sul1 = df_final_saresp[df_final_saresp['DE'].str.contains("SUL 1", case=False, na=False)]
media_saresp = df_saresp_sul1.groupby('SERIE_ANO')[['LP', 'MAT']].mean().stack().reset_index()
media_saresp.columns = ['S√©rie', 'Disciplina', 'Nota M√©dia']

plt.title("Desempenho M√©dio no SARESP - Sul 1\n(por s√©rie e disciplina)")
grafico = sns.barplot(data=media_saresp, y='S√©rie', x='Nota M√©dia', hue='Disciplina',
                      palette=paleta_cores['SARESP'])
valor_barras(grafico, 1)
plt.xlabel('Nota M√©dia')
plt.ylabel('S√©rie')
plt.legend(title='Disciplina')

# 4. GR√ÅFICO 3: DISTRIBUI√á√ÉO RACIAL (df_raca_Sul1eJundiai)
plt.subplot(1, 3, 3)
df_raca_sul1 = df_raca_Sul1eJundiai[df_raca_Sul1eJundiai['DE'] == 'SUL 1']
distribuicao_racial = df_raca_sul1[['Branca', 'Pretos_e_Pardos', 'N√£o declarada']].sum()

plt.title("Distribui√ß√£o Racial - Sul 1\n(Brancos vs Negros)")
grafico_setores_1(distribuicao_racial, paleta_cores['RA√áA'])

# 5. AJUSTES FINAIS
plt.tight_layout(pad=3.0)  # Aumenta o padding entre os gr√°ficos
plt.show()

# 1. Juntar Simulado e SARESP (ambos t√™m SERIE_ANO)
df_simulado_agg = df_final_simulado.groupby(['SERIE_ANO', 'DE', 'ESCOLA', 'Disciplina'])['Taxa_Acerto'].mean().reset_index()
df_saresp_agg = df_final_saresp.groupby(['SERIE_ANO', 'DE', 'ESCOLA'])[['LP', 'MAT']].mean().reset_index()

# Merge Simulado + SARESP
df_combined = pd.merge(
    df_simulado_agg,
    df_saresp_agg,
    on=['SERIE_ANO', 'DE', 'ESCOLA'],
    how='inner'  # Mant√©m apenas escolas presentes nos dois
)

# 2. Adicionar dados raciais (sem SERIE_ANO, apenas por escola)
df_final = pd.merge(
    df_combined,
    df_raca_Sul1eJundiai[['DE', 'ESCOLA', 'M√©dia_Branca', 'M√©dia_Pretos_e_Pardos']],
    on=['DE', 'ESCOLA'],
    how='left'  # Mant√©m todas as escolas do merge anterior, mesmo sem dados raciais
)

# Verificar resultado
print(df_final.head())
print("\nColunas dispon√≠veis:", df_final.columns.tolist())

# Converter colunas para num√©rico, for√ßando valores inv√°lidos para NaN
df_final['M√©dia_Pretos_e_Pardos'] = pd.to_numeric(df_final['M√©dia_Pretos_e_Pardos'], errors='coerce')
df_final['Taxa_Acerto'] = pd.to_numeric(df_final['Taxa_Acerto'], errors='coerce')

# Remover linhas com NaN (opcional)
df_final_clean = df_final.dropna(subset=['M√©dia_Pretos_e_Pardos', 'Taxa_Acerto'])

import seaborn as sns
import matplotlib.pyplot as plt

# Configurar estilo
sns.set(style="whitegrid")

# Gr√°fico de regress√£o
g = sns.lmplot(
    data=df_final_clean,
    x='M√©dia_Pretos_e_Pardos',
    y='Taxa_Acerto',
    col='Disciplina',
    facet_kws={'sharey': True, 'sharex': True},
    height=5,
    aspect=1.2
)

# Ajustar t√≠tulo
g.fig.suptitle('Taxa de acerto no simulado vs % de alunos pretos/pardos', y=1.05)

# Ajustar eixos
g.set_axis_labels("% de alunos pretos/pardos", "Taxa de acerto (%)")

plt.tight_layout()
plt.show()

